import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { getServerSession } from 'next-auth'
import { authConfig } from '@/lib/auth-config'
import { Octokit } from '@octokit/rest'

// Force dynamic rendering for API routes with auth
export const dynamic = 'force-dynamic'

const prisma = new PrismaClient()

interface TriggerGitHubActionsRequest {
  taskId: string
  source: 'task_assignment' | 'manual_trigger'
  repositoryName?: string
}

/**
 * API endpoint to trigger GitHub Actions workflows for AI coding tasks
 * Called when tasks are assigned to the coding agent
 */
export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ [GitHub Actions Trigger] Received trigger request')

    // Parse request
    const body: TriggerGitHubActionsRequest = await request.json()
    const { taskId, source, repositoryName } = body

    if (!taskId) {
      return NextResponse.json({ error: 'Task ID is required' }, { status: 400 })
    }

    console.log(`üìã [GitHub Actions Trigger] Task: ${taskId}, Source: ${source}`)

    // Get session to identify the user
    const session = await getServerSession(authConfig)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    // Get the task details
    const task = await prisma.task.findUnique({
      where: { id: taskId },
      include: {
        creator: {
          include: {
            githubIntegration: true
          }
        },
        assignee: true,
        lists: {
          include: {
            owner: {
              include: {
                githubIntegration: true
              }
            }
          }
        }
      }
    })

    if (!task) {
      return NextResponse.json({ error: 'Task not found' }, { status: 404 })
    }

    // Verify the task is assigned to a coding agent
    if (!task.assignee || !task.assignee.isAIAgent || task.assignee.aiAgentType !== 'coding_agent') {
      return NextResponse.json({
        error: 'Task is not assigned to a coding agent'
      }, { status: 400 })
    }

    console.log(`üìã [GitHub Actions Trigger] Task: "${task.title}"`)
    console.log(`üë§ [GitHub Actions Trigger] Creator: ${task.creator.name}`)

    // Determine which GitHub integration to use
    // Priority: 1. List owner's GitHub integration, 2. Task creator's GitHub integration
    let githubIntegration = null
    let targetRepository = repositoryName

    // Check list owner's GitHub integration first
    if (task.lists.length > 0 && task.lists[0].owner.githubIntegration) {
      githubIntegration = task.lists[0].owner.githubIntegration
      console.log(`üîß [GitHub Actions Trigger] Using list owner's GitHub integration`)
    }
    // Fallback to task creator's GitHub integration
    else if (task.creator.githubIntegration) {
      githubIntegration = task.creator.githubIntegration
      console.log(`üîß [GitHub Actions Trigger] Using task creator's GitHub integration`)
    }

    if (!githubIntegration) {
      return NextResponse.json({
        error: 'No GitHub integration configured',
        message: 'GitHub integration is required to trigger cloud-based workflows'
      }, { status: 400 })
    }

    // Parse repository information from GitHub integration
    let repositories = []
    try {
      repositories = typeof githubIntegration.repositories === 'string'
        ? JSON.parse(githubIntegration.repositories)
        : githubIntegration.repositories || []
    } catch (e) {
      console.error('Failed to parse GitHub repositories:', e)
      repositories = []
    }

    if (repositories.length === 0) {
      return NextResponse.json({
        error: 'No repositories configured in GitHub integration'
      }, { status: 400 })
    }

    // Use the specified repository or the first available one
    const repository = targetRepository
      ? repositories.find((repo: any) => repo.fullName === targetRepository || repo.name === targetRepository)
      : repositories[0]

    if (!repository) {
      return NextResponse.json({
        error: `Repository ${targetRepository || 'default'} not found in GitHub integration`
      }, { status: 400 })
    }

    console.log(`üìÇ [GitHub Actions Trigger] Target repository: ${repository.fullName}`)

    // Check if GitHub App credentials are available
    if (!process.env.GITHUB_APP_ID || !process.env.GITHUB_APP_PRIVATE_KEY) {
      return NextResponse.json({
        error: 'GitHub App credentials not configured',
        message: 'GITHUB_APP_ID and GITHUB_APP_PRIVATE_KEY environment variables are required'
      }, { status: 500 })
    }

    // Initialize Octokit with GitHub App authentication
    let octokit: Octokit
    try {
      if (githubIntegration.installationId) {
        // Use GitHub App installation authentication
        const { App } = await import('@octokit/app')
        const app = new App({
          appId: parseInt(process.env.GITHUB_APP_ID!),
          privateKey: process.env.GITHUB_APP_PRIVATE_KEY!,
        })

        octokit = (await app.getInstallationOctokit(githubIntegration.installationId)) as Octokit
      } else {
        throw new Error('No GitHub App installation ID found')
      }
    } catch (error) {
      console.error('Failed to authenticate with GitHub:', error)
      return NextResponse.json({
        error: 'GitHub authentication failed',
        message: 'Unable to authenticate with GitHub App'
      }, { status: 500 })
    }

    console.log(`üîê [GitHub Actions Trigger] GitHub authentication successful`)

    // Parse repository owner and name
    const [owner, repo] = repository.fullName.split('/')
    if (!owner || !repo) {
      return NextResponse.json({
        error: 'Invalid repository format',
        message: `Expected format: owner/repo, got: ${repository.fullName}`
      }, { status: 400 })
    }

    // Trigger the repository_dispatch event to run GitHub Actions
    try {
      console.log(`üöÄ [GitHub Actions Trigger] Triggering repository_dispatch for ${owner}/${repo}`)

      await octokit.repos.createDispatchEvent({
        owner,
        repo,
        event_type: 'astrid-task-assigned',
        client_payload: {
          task_id: taskId,
          task_title: task.title,
          task_description: task.description || '',
          creator_name: task.creator.name,
          creator_id: task.creator.id,
          assignee_name: task.assignee.name,
          assignee_id: task.assignee.id,
          source: source,
          timestamp: new Date().toISOString(),
          astrid_url: process.env.NEXTAUTH_URL || 'http://localhost:3000',
          task_url: `${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/tasks/${taskId}`
        }
      })

      console.log(`‚úÖ [GitHub Actions Trigger] Repository dispatch event sent successfully`)

      // Update task with GitHub Actions trigger information
      await prisma.comment.create({
        data: {
          content: `üöÄ **Cloud-Based AI Workflow Triggered**

GitHub Actions workflow has been triggered for cloud-based implementation!

**Repository:** ${repository.fullName}
**Workflow:** Astrid AI Coding Agent
**Trigger Source:** ${source === 'task_assignment' ? 'Task Assignment' : 'Manual Trigger'}
**Status:** Cloud build and AI implementation starting...

**What happens next:**
1. üèóÔ∏è **Cloud Build** - Code builds and tests run on GitHub runners
2. ü§ñ **AI Analysis** - AI agent analyzes task and creates implementation plan
3. üìã **Plan Review** - Implementation plan posted for your approval
4. ‚öôÔ∏è **Code Generation** - AI generates and commits code after approval
5. üåê **Preview Deployment** - Automatic deployment to staging for testing

**GitHub Actions URL:** https://github.com/${repository.fullName}/actions

You can monitor the progress in GitHub Actions and here in the task comments! üéØ`,
          type: 'MARKDOWN',
          taskId,
          authorId: task.assignee.id
        }
      })

      console.log(`‚úÖ [GitHub Actions Trigger] Status comment added to task`)

      // Return success response
      return NextResponse.json({
        success: true,
        taskId,
        repository: repository.fullName,
        githubActionsUrl: `https://github.com/${repository.fullName}/actions`,
        message: 'GitHub Actions workflow triggered successfully',
        workflowType: 'cloud-based',
        dispatchEvent: 'astrid-task-assigned'
      }, { status: 200 })

    } catch (githubError: any) {
      console.error('‚ùå [GitHub Actions Trigger] GitHub API error:', githubError)

      // Return error but don't fail completely - this allows fallback to local orchestration
      return NextResponse.json({
        error: 'GitHub Actions trigger failed',
        message: githubError.message || 'Unknown GitHub API error',
        githubError: true,
        fallbackAvailable: true
      }, { status: 400 })
    }

  } catch (error) {
    console.error('‚ùå [GitHub Actions Trigger] Error:', error)

    return NextResponse.json({
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? (error instanceof Error ? error.message : String(error)) : undefined,
      fallbackAvailable: true
    }, { status: 500 })
  }
}

/**
 * GET endpoint to check GitHub Actions trigger availability
 */
export async function GET() {
  const hasGitHubApp = !!(process.env.GITHUB_APP_ID && process.env.GITHUB_APP_PRIVATE_KEY)

  return NextResponse.json({
    service: 'GitHub Actions AI Trigger',
    status: hasGitHubApp ? 'available' : 'configuration_required',
    version: '1.0.0',
    configuration: {
      githubAppConfigured: hasGitHubApp,
      requiredEnvVars: [
        'GITHUB_APP_ID',
        'GITHUB_APP_PRIVATE_KEY'
      ],
      githubWorkflows: [
        'astrid-code-assistant.yml',
        'preview-deployment.yml'
      ]
    },
    endpoints: {
      trigger: 'POST /api/coding-agent/trigger-github-actions',
      githubWebhook: 'POST /api/coding-agent/github-trigger',
      workflowComplete: 'POST /api/coding-agent/workflow-complete',
      previewReady: 'POST /api/coding-agent/preview-ready'
    },
    documentation: 'See GitHub Actions workflows in .github/workflows/',
    fallback: 'Local AI orchestration available if GitHub Actions unavailable'
  })
}