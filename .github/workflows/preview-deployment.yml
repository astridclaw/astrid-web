name: 'Preview Deployment'

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'app/**'
      - 'components/**'
      - 'lib/**'
      - 'hooks/**'
      - 'types/**'
      - 'prisma/**'
      - 'package.json'
      - 'package-lock.json'
      - 'tsconfig.json'
      - 'tailwind.config.js'
      - 'next.config.js'

env:
  NODE_VERSION: '20'
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
  # Job 1: Build and Test PR
  build-test:
    name: 'Build & Test PR'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      build-success: ${{ steps.build-status.outputs.success }}
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run TypeScript Check
        run: npm run typecheck

      - name: Check Prisma Schema Drift
        env:
          # Dummy values - not actually connecting to DB, just validating schema matches migrations
          DATABASE_URL: "postgresql://x:x@localhost:5432/x"
          DATABASE_URL_DIRECT: "postgresql://x:x@localhost:5432/x"
        run: |
          echo "Checking if Prisma schema matches migrations..."
          # Compare the schema against the migrations folder (not the live database)
          # This detects if someone added fields to schema.prisma without creating a migration

          # Use prisma format to validate schema, then check migration status
          npx prisma validate

          # Generate a temporary migration to see if there are uncommitted schema changes
          # This doesn't require a database connection
          DIFF=$(npx prisma migrate diff \
            --from-empty \
            --to-schema-datamodel ./prisma/schema.prisma \
            --script 2>&1) || true

          # Get what the migrations folder would produce
          MIGRATION_SQL=""
          for migration in prisma/migrations/*/migration.sql; do
            if [ -f "$migration" ]; then
              MIGRATION_SQL="$MIGRATION_SQL$(cat "$migration")\n"
            fi
          done

          # Check if schema.prisma defines tables/columns not in any migration file
          # We look for CREATE TABLE statements in the diff that aren't in migrations
          # Note: prisma migrate diff outputs "CREATE TABLE "TableName"" but migrations may use
          # "CREATE TABLE "public"."TableName"" (schema-qualified), so we extract just the table name
          SCHEMA_TABLES=$(echo "$DIFF" | grep -oE 'CREATE TABLE "[^"]+"' | sed 's/CREATE TABLE "//' | sed 's/"$//' | sort -u || true)

          MISSING_TABLES=""
          while IFS= read -r table_name; do
            # Skip empty lines
            if [ -z "$table_name" ]; then
              continue
            fi
            # Search for CREATE TABLE with this name, allowing for optional schema prefix like "public".
            if ! grep -qE "CREATE TABLE (\"public\"\\.)?\"${table_name}\"" prisma/migrations/*/migration.sql 2>/dev/null; then
              MISSING_TABLES="${MISSING_TABLES}CREATE TABLE \"${table_name}\"\n"
            fi
          done <<< "$SCHEMA_TABLES"

          if [ -n "$MISSING_TABLES" ]; then
            echo ""
            echo "‚ùå ERROR: Prisma schema has changes that are not in migrations!"
            echo ""
            echo "Missing from migrations:"
            echo -e "$MISSING_TABLES"
            echo ""
            echo "To fix this, run locally:"
            echo "  npx prisma migrate dev --name <describe_your_change>"
            echo ""
            echo "Then commit the new migration file in prisma/migrations/"
            exit 1
          fi
          echo "‚úÖ Prisma schema matches migrations"

      - name: Check API/iOS Model Sync
        run: |
          echo "Checking if Prisma, Swift, and Core Data models are in sync..."
          npm run check:model-sync

      - name: Check for API Breaking Changes
        run: |
          echo "Checking for API breaking changes..."
          npm run check:api-breaking

      - name: Run Linting
        run: npm run lint

      - name: Run Tests
        run: npm test
        env:
          NODE_ENV: test

      - name: Build Application
        id: build-app
        run: |
          echo "Building application for preview..."
          npm run build
        env:
          NODE_ENV: production
          # Use preview database for builds if needed
          DATABASE_URL: ${{ secrets.DATABASE_URL_PREVIEW || secrets.DATABASE_URL }}

      - name: Set Build Status
        id: build-status
        run: |
          echo "success=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Build and tests completed successfully"

  # Job 2: Deploy to Vercel Preview
  deploy-preview:
    name: 'Deploy Vercel Preview'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-test
    if: needs.build-test.outputs.build-success == 'true'
    outputs:
      preview-url: ${{ steps.deploy.outputs.preview-url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Information
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project Artifacts
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy to Vercel
        id: deploy
        run: |
          echo "Deploying to Vercel preview..."

          # Deploy to Vercel and capture output
          DEPLOYMENT_OUTPUT=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }} 2>&1)
          echo "Deployment output:"
          echo "$DEPLOYMENT_OUTPUT"

          # Extract preview URL from output
          PREVIEW_URL=$(echo "$DEPLOYMENT_OUTPUT" | grep -E 'https://.*\.vercel\.app' | tail -1 | tr -d ' ')

          if [ -z "$PREVIEW_URL" ]; then
            echo "‚ùå Failed to extract preview URL from deployment output"
            exit 1
          fi

          echo "‚úÖ Deployed to: $PREVIEW_URL"
          echo "preview-url=$PREVIEW_URL" >> $GITHUB_OUTPUT

          # Extract deployment ID if possible
          DEPLOYMENT_ID=$(echo "$PREVIEW_URL" | sed -E 's|https://([^.]+)\..*|\1|')
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Update PR with Preview URL
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const previewUrl = '${{ steps.deploy.outputs.preview-url }}';
            const deploymentId = '${{ steps.deploy.outputs.deployment-id }}';

            // Comment on PR with preview link
            const comment = `## üåê Preview Deployment Ready!

            **Preview URL:** [${previewUrl}](${previewUrl})
            **Deployment ID:** \`${deploymentId}\`

            ### üß™ Testing Checklist
            - [ ] Authentication flow works
            - [ ] Task creation and editing
            - [ ] List management
            - [ ] Comments and collaboration
            - [ ] Mobile responsiveness

            ### ü§ñ AI Agent Status
            ${context.payload.pull_request.user.login === 'astrid-code-assistant' ? '‚úÖ This PR was created by the Astrid AI Coding Agent' : '‚ÑπÔ∏è Manual PR - not from AI agent'}

            ---
            *Deployed from commit ${context.sha.substring(0, 7)}*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Job 3: Run E2E Tests on Preview (Optional)
  e2e-tests:
    name: 'E2E Tests on Preview'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-preview
    if: needs.deploy-preview.outputs.preview-url != ''
    continue-on-error: true  # Don't fail the workflow if E2E tests fail
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Wait for Deployment
        run: |
          echo "Waiting for deployment to be ready..."
          PREVIEW_URL="${{ needs.deploy-preview.outputs.preview-url }}"

          # Wait up to 5 minutes for deployment to be ready
          MAX_ATTEMPTS=60
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Checking if deployment is ready..."

            if curl -s --head --fail --max-time 10 "$PREVIEW_URL" > /dev/null 2>&1; then
              echo "‚úÖ Deployment is ready!"
              break
            fi

            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå Deployment not ready after 5 minutes"
              exit 1
            fi

            sleep 5
          done

      - name: Run Basic Smoke Tests
        run: |
          PREVIEW_URL="${{ needs.deploy-preview.outputs.preview-url }}"
          echo "Running smoke tests against: $PREVIEW_URL"

          # Test home page
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL")
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Home page loads successfully"
          else
            echo "‚ùå Home page failed with status: $HTTP_STATUS"
            exit 1
          fi

          # Test API health endpoint (if it exists)
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL/api/health" || echo "404")
          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ÑπÔ∏è API health endpoint not available (status: $HEALTH_STATUS)"
          fi

          echo "üéØ Basic smoke tests completed successfully!"

  # Job 4: Security Scan (Optional)
  security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: build-test
    if: needs.build-test.outputs.build-success == 'true'
    continue-on-error: true
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Run npm audit
        run: |
          echo "Running npm security audit..."
          npm audit --audit-level moderate || true

      - name: Check for secrets in code
        run: |
          echo "Checking for potential secrets in code..."
          # Basic check for common secret patterns
          if grep -r --include="*.ts" --include="*.js" --include="*.tsx" --include="*.jsx" \
             -E "(password|secret|key|token).*=.*['\"][^'\"]{10,}['\"]" . || true; then
            echo "‚ö†Ô∏è Potential secrets found - please review"
          else
            echo "‚úÖ No obvious secrets detected"
          fi

  # Job 5: Notify AI Agent (if PR is from AI)
  notify-ai-agent:
    name: 'Notify AI Agent'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build-test, deploy-preview]
    if: always() && github.event.pull_request.user.login == 'astrid-code-assistant'
    steps:
      - name: Extract Task ID from PR
        id: extract-task
        run: |
          # Try to extract task ID from PR title or body
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"

          # Look for task ID pattern in title or body
          TASK_ID=$(echo "$PR_TITLE $PR_BODY" | grep -oE "task[_-]?id:?\s*[a-zA-Z0-9-]{8,}" | head -1 | sed -E 's/.*[_-]?id:?\s*//')

          if [ -n "$TASK_ID" ]; then
            echo "Found task ID: $TASK_ID"
            echo "task_id=$TASK_ID" >> $GITHUB_OUTPUT
          else
            echo "No task ID found in PR title or body"
          fi

      - name: Update Astrid Task Status
        if: steps.extract-task.outputs.task_id != ''
        env:
          ASTRID_WEBHOOK_URL: ${{ secrets.ASTRID_WEBHOOK_URL || 'https://astrid.cc' }}
          ASTRID_MCP_TOKEN: ${{ secrets.ASTRID_MCP_TOKEN }}
          TASK_ID: ${{ steps.extract-task.outputs.task_id }}
          PREVIEW_URL: ${{ needs.deploy-preview.outputs.preview-url }}
          BUILD_SUCCESS: ${{ needs.build-test.outputs.build-success }}
        run: |
          echo "Updating Astrid task status..."

          STATUS="TESTING"
          if [ "$BUILD_SUCCESS" != "true" ]; then
            STATUS="FAILED"
          fi

          curl -s -X POST "$ASTRID_WEBHOOK_URL/api/coding-agent/preview-ready" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ASTRID_MCP_TOKEN" \
            -d "{
              \"taskId\": \"$TASK_ID\",
              \"status\": \"$STATUS\",
              \"previewUrl\": \"$PREVIEW_URL\",
              \"prUrl\": \"${{ github.event.pull_request.html_url }}\",
              \"githubContext\": {
                \"repository\": \"${{ github.repository }}\",
                \"pr_number\": ${{ github.event.pull_request.number }},
                \"sha\": \"${{ github.event.pull_request.head.sha }}\"
              }
            }" || echo "Warning: Could not update Astrid task status"

  # Job 6: Summary
  summary:
    name: 'Deployment Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build-test, deploy-preview, e2e-tests]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "## üöÄ Preview Deployment Summary"
          echo ""
          echo "**Build Status:** ${{ needs.build-test.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}"
          echo "**Deployment Status:** ${{ needs.deploy-preview.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}"
          echo "**E2E Tests:** ${{ needs.e2e-tests.result == 'success' && '‚úÖ Passed' || needs.e2e-tests.result == 'failure' && '‚ùå Failed' || '‚ÑπÔ∏è Skipped' }}"
          echo ""

          if [ -n "${{ needs.deploy-preview.outputs.preview-url }}" ]; then
            echo "**üåê Preview URL:** ${{ needs.deploy-preview.outputs.preview-url }}"
            echo ""
          fi

          if [ "${{ github.event.pull_request.user.login }}" = "astrid-code-assistant" ]; then
            echo "ü§ñ **AI-Generated PR**"
            echo "This pull request was automatically created by the Astrid AI Coding Agent."
            echo "Review the changes and preview, then approve for production deployment."
          fi

          echo ""
          echo "**Next Steps:**"
          echo "1. üëÄ Review the code changes in this PR"
          echo "2. üß™ Test the functionality using the preview URL"
          echo "3. ‚úÖ Approve and merge when ready for production"