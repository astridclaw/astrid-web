#!/usr/bin/env node
#!/usr/bin/env node
"use strict";
/**
 * Astrid MCP Server V3 - OAuth-Enabled
 *
 * This MCP server uses OAuth 2.0 client credentials flow for authentication,
 * eliminating the need for manual token provisioning.
 *
 * Configuration via environment variables:
 * - ASTRID_OAUTH_CLIENT_ID: OAuth client ID
 * - ASTRID_OAUTH_CLIENT_SECRET: OAuth client secret
 * - ASTRID_OAUTH_LIST_ID: Default list ID to operate on
 * - ASTRID_API_BASE_URL: API base URL (default: https://astrid.cc)
 */
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("@modelcontextprotocol/sdk/server/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const zod_1 = require("zod");
// Schema definitions for validation
const CreateTaskSchema = zod_1.z.object({
    title: zod_1.z.string().min(1),
    description: zod_1.z.string().optional(),
    priority: zod_1.z.number().min(0).max(3).default(0),
    assigneeId: zod_1.z.string().optional(),
    dueDateTime: zod_1.z.string().datetime().optional(),
    reminderTime: zod_1.z.string().datetime().optional(),
    reminderType: zod_1.z.enum(["push", "email", "both"]).optional(),
    isPrivate: zod_1.z.boolean().default(true),
});
const UpdateTaskSchema = zod_1.z.object({
    taskId: zod_1.z.string(),
    title: zod_1.z.string().min(1).optional(),
    description: zod_1.z.string().optional(),
    priority: zod_1.z.number().min(0).max(3).optional(),
    assigneeId: zod_1.z.string().optional(),
    dueDateTime: zod_1.z.string().datetime().optional(),
    reminderTime: zod_1.z.string().datetime().optional(),
    reminderType: zod_1.z.enum(["push", "email", "both"]).optional(),
    isPrivate: zod_1.z.boolean().optional(),
    completed: zod_1.z.boolean().optional(),
});
const CreateCommentSchema = zod_1.z.object({
    taskId: zod_1.z.string(),
    content: zod_1.z.string().min(1),
    type: zod_1.z.enum(["TEXT", "MARKDOWN"]).default("TEXT"),
});
/**
 * OAuth API Client for Astrid
 */
class OAuthAPIClient {
    constructor(baseUrl = "https://astrid.cc", clientId, clientSecret) {
        this.accessToken = null;
        this.tokenExpiry = 0;
        this.baseUrl = baseUrl;
        this.clientId = clientId || process.env.ASTRID_OAUTH_CLIENT_ID || "";
        this.clientSecret = clientSecret || process.env.ASTRID_OAUTH_CLIENT_SECRET || "";
        if (!this.clientId || !this.clientSecret) {
            console.error("‚ùå OAuth credentials not configured");
            throw new Error("ASTRID_OAUTH_CLIENT_ID and ASTRID_OAUTH_CLIENT_SECRET are required");
        }
    }
    /**
     * Obtain an access token using client credentials flow
     */
    async obtainAccessToken() {
        // Check if we have a valid token
        if (this.accessToken && Date.now() < this.tokenExpiry) {
            return this.accessToken;
        }
        console.error("üîë Obtaining OAuth access token...");
        const response = await fetch(`${this.baseUrl}/api/v1/oauth/token`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                grant_type: "client_credentials",
                client_id: this.clientId,
                client_secret: this.clientSecret,
            }),
        });
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        // Set expiry to 5 minutes before actual expiry for safety
        this.tokenExpiry = Date.now() + (data.expires_in - 300) * 1000;
        console.error("‚úÖ Access token obtained successfully");
        return this.accessToken;
    }
    /**
     * Make an authenticated API request
     */
    async makeRequest(endpoint, options = {}) {
        const token = await this.obtainAccessToken();
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
            ...options,
            headers: {
                ...options.headers,
                "X-OAuth-Token": token, // Use X-OAuth-Token header (works in production)
                "Content-Type": "application/json",
            },
        });
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: response.statusText }));
            throw new Error(error.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    }
}
/**
 * MCP Server V3 - OAuth-Enabled
 */
class AstridMCPServerOAuth {
    constructor() {
        this.defaultListId = null;
        const baseUrl = process.env.ASTRID_API_BASE_URL || "https://astrid.cc";
        this.oauthClient = new OAuthAPIClient(baseUrl);
        this.defaultListId = process.env.ASTRID_OAUTH_LIST_ID || null;
        this.server = new index_js_1.Server({
            name: "astrid-task-manager-oauth",
            version: "3.0.0",
        }, {
            capabilities: {
                resources: {},
                tools: {},
            },
        });
        this.setupHandlers();
    }
    setupHandlers() {
        // List available tools
        this.server.setRequestHandler(types_js_1.ListToolsRequestSchema, async () => {
            return {
                tools: [
                    {
                        name: "get_lists",
                        description: "Get all task lists accessible to the authenticated user",
                        inputSchema: {
                            type: "object",
                            properties: {},
                        },
                    },
                    {
                        name: "get_tasks",
                        description: "Get all tasks from a specific list (or default list if not specified)",
                        inputSchema: {
                            type: "object",
                            properties: {
                                listId: {
                                    type: "string",
                                    description: "ID of the list to get tasks from (optional, uses default list if not provided)",
                                },
                                includeCompleted: {
                                    type: "boolean",
                                    description: "Whether to include completed tasks",
                                    default: false,
                                },
                            },
                        },
                    },
                    {
                        name: "get_task",
                        description: "Get detailed information about a specific task",
                        inputSchema: {
                            type: "object",
                            properties: {
                                taskId: {
                                    type: "string",
                                    description: "ID of the task",
                                },
                            },
                            required: ["taskId"],
                        },
                    },
                    {
                        name: "create_task",
                        description: "Create a new task in a list",
                        inputSchema: {
                            type: "object",
                            properties: {
                                listId: {
                                    type: "string",
                                    description: "ID of the list to create task in (optional, uses default list if not provided)",
                                },
                                title: {
                                    type: "string",
                                    description: "Task title",
                                },
                                description: {
                                    type: "string",
                                    description: "Task description",
                                },
                                priority: {
                                    type: "number",
                                    minimum: 0,
                                    maximum: 3,
                                    description: "Task priority (0-3)",
                                },
                                dueDateTime: {
                                    type: "string",
                                    format: "date-time",
                                    description: "Due date and time",
                                },
                            },
                            required: ["title"],
                        },
                    },
                    {
                        name: "update_task",
                        description: "Update an existing task",
                        inputSchema: {
                            type: "object",
                            properties: {
                                taskId: {
                                    type: "string",
                                    description: "ID of the task to update",
                                },
                                title: {
                                    type: "string",
                                    description: "New task title",
                                },
                                description: {
                                    type: "string",
                                    description: "New task description",
                                },
                                priority: {
                                    type: "number",
                                    minimum: 0,
                                    maximum: 3,
                                    description: "New priority (0-3)",
                                },
                                completed: {
                                    type: "boolean",
                                    description: "Mark as completed/incomplete",
                                },
                                dueDateTime: {
                                    type: "string",
                                    format: "date-time",
                                    description: "New due date and time",
                                },
                            },
                            required: ["taskId"],
                        },
                    },
                    {
                        name: "add_comment",
                        description: "Add a comment to a task",
                        inputSchema: {
                            type: "object",
                            properties: {
                                taskId: {
                                    type: "string",
                                    description: "ID of the task",
                                },
                                content: {
                                    type: "string",
                                    description: "Comment content",
                                },
                                type: {
                                    type: "string",
                                    enum: ["TEXT", "MARKDOWN"],
                                    description: "Comment type",
                                    default: "TEXT",
                                },
                            },
                            required: ["taskId", "content"],
                        },
                    },
                    {
                        name: "get_task_comments",
                        description: "Get all comments for a specific task",
                        inputSchema: {
                            type: "object",
                            properties: {
                                taskId: {
                                    type: "string",
                                    description: "ID of the task",
                                },
                            },
                            required: ["taskId"],
                        },
                    },
                ],
            };
        });
        // List available resources
        this.server.setRequestHandler(types_js_1.ListResourcesRequestSchema, async () => {
            return {
                resources: [
                    {
                        uri: "lists://all",
                        name: "All Task Lists",
                        description: "All task lists accessible via OAuth",
                        mimeType: "application/json",
                    },
                ],
            };
        });
        // Read resources
        this.server.setRequestHandler(types_js_1.ReadResourceRequestSchema, async (request) => {
            const { uri } = request.params;
            if (uri === "lists://all") {
                return {
                    contents: [
                        {
                            uri,
                            mimeType: "application/json",
                            text: JSON.stringify({
                                description: "Task lists accessible via OAuth",
                                authentication: "OAuth 2.0 client credentials flow",
                                defaultListId: this.defaultListId,
                            }),
                        },
                    ],
                };
            }
            throw new Error(`Unknown resource: ${uri}`);
        });
        // Handle tool calls
        this.server.setRequestHandler(types_js_1.CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;
            try {
                switch (name) {
                    case "get_lists":
                        return await this.getLists();
                    case "get_tasks":
                        return await this.getTasks(args);
                    case "get_task":
                        return await this.getTask(args);
                    case "create_task":
                        return await this.createTask(args);
                    case "update_task":
                        return await this.updateTask(args);
                    case "add_comment":
                        return await this.addComment(args);
                    case "get_task_comments":
                        return await this.getTaskComments(args);
                    default:
                        throw new Error(`Unknown tool: ${name}`);
                }
            }
            catch (error) {
                return {
                    content: [
                        {
                            type: "text",
                            text: `Error: ${error instanceof Error ? error.message : String(error)}`,
                        },
                    ],
                    isError: true,
                };
            }
        });
    }
    async getLists() {
        const data = await this.oauthClient.makeRequest("/api/v1/lists");
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        lists: data.lists,
                        defaultListId: this.defaultListId,
                    }, null, 2),
                },
            ],
        };
    }
    async getTasks(args) {
        const listId = args.listId || this.defaultListId;
        if (!listId) {
            throw new Error("No list ID provided and no default list configured. Set ASTRID_OAUTH_LIST_ID or provide listId parameter.");
        }
        const params = new URLSearchParams();
        params.append("listId", listId);
        if (args.includeCompleted) {
            params.append("includeCompleted", "true");
        }
        const data = await this.oauthClient.makeRequest(`/api/v1/tasks?${params.toString()}`);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        listId,
                        tasks: data.tasks,
                    }, null, 2),
                },
            ],
        };
    }
    async getTask(args) {
        const { taskId } = args;
        if (!taskId) {
            throw new Error("taskId is required");
        }
        const data = await this.oauthClient.makeRequest(`/api/v1/tasks/${taskId}`);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify(data.task, null, 2),
                },
            ],
        };
    }
    async createTask(args) {
        const listId = args.listId || this.defaultListId;
        if (!listId) {
            throw new Error("No list ID provided and no default list configured. Set ASTRID_OAUTH_LIST_ID or provide listId parameter.");
        }
        // Validate task data
        const taskData = CreateTaskSchema.parse({
            title: args.title,
            description: args.description,
            priority: args.priority,
            dueDateTime: args.dueDateTime,
        });
        const data = await this.oauthClient.makeRequest("/api/v1/tasks", {
            method: "POST",
            body: JSON.stringify({
                ...taskData,
                listId,
            }),
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        task: data.task,
                    }, null, 2),
                },
            ],
        };
    }
    async updateTask(args) {
        // Validate update data
        const updateData = UpdateTaskSchema.parse(args);
        const { taskId, ...updates } = updateData;
        const data = await this.oauthClient.makeRequest(`/api/v1/tasks/${taskId}`, {
            method: "PATCH",
            body: JSON.stringify(updates),
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        task: data.task,
                    }, null, 2),
                },
            ],
        };
    }
    async addComment(args) {
        // Validate comment data
        const commentData = CreateCommentSchema.parse(args);
        const data = await this.oauthClient.makeRequest(`/api/v1/tasks/${commentData.taskId}/comments`, {
            method: "POST",
            body: JSON.stringify({
                content: commentData.content,
                type: commentData.type,
            }),
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        comment: data.comment,
                    }, null, 2),
                },
            ],
        };
    }
    async getTaskComments(args) {
        const { taskId } = args;
        if (!taskId) {
            throw new Error("taskId is required");
        }
        const data = await this.oauthClient.makeRequest(`/api/v1/tasks/${taskId}/comments`);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        taskId,
                        comments: data.comments,
                    }, null, 2),
                },
            ],
        };
    }
    async run() {
        const transport = new stdio_js_1.StdioServerTransport();
        await this.server.connect(transport);
        console.error("Astrid MCP Server (OAuth) running on stdio");
        console.error(`Base URL: ${process.env.ASTRID_API_BASE_URL || "https://astrid.cc"}`);
        console.error(`Default List: ${this.defaultListId || "none (must provide listId in each call)"}`);
    }
}
// Run the server if this file is executed directly
if (require.main === module) {
    const server = new AstridMCPServerOAuth();
    server.run().catch(console.error);
}
module.exports = AstridMCPServerOAuth;
