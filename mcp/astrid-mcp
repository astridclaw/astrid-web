#!/usr/bin/env node
#!/usr/bin/env node
const { Server } = require("@modelcontextprotocol/sdk/server/index.js");
const { StdioServerTransport } = require("@modelcontextprotocol/sdk/server/stdio.js");
const { CallToolRequestSchema, ListResourcesRequestSchema, ListToolsRequestSchema, ReadResourceRequestSchema, } = require("@modelcontextprotocol/sdk/types.js");
const { z } = require("zod");
// We'll need to initialize Prisma and utility functions here since we can't import from the Next.js app
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
// Simple in-memory token store for the MCP server
// In production, this should be shared with the main app through Redis or database
const mcpTokenStore = new Map();
// Helper function to get all member IDs from a list
function getListMemberIds(list) {
    const memberIds = new Set();
    // Add owner
    if (list.ownerId) {
        memberIds.add(list.ownerId);
    }
    // Add admins
    if (list.admins) {
        list.admins.forEach((admin) => memberIds.add(admin.id));
    }
    // Add members
    if (list.members) {
        list.members.forEach((member) => memberIds.add(member.id));
    }
    // Add new-style list members
    if (list.listMembers) {
        list.listMembers.forEach((member) => memberIds.add(member.userId));
    }
    return Array.from(memberIds);
}
// Schema definitions for validation
const ListAccessTokenSchema = z.object({
    listId: z.string(),
    userId: z.string(),
    permissions: z.array(z.enum(["read", "write", "admin"])),
    expiresAt: z.date().optional(),
});
const CreateTaskSchema = z.object({
    title: z.string().min(1),
    description: z.string().optional(),
    priority: z.number().min(0).max(3).default(0),
    assigneeId: z.string().optional(),
    dueDateTime: z.string().datetime().optional(),
    reminderTime: z.string().datetime().optional(),
    reminderType: z.enum(["push", "email", "both"]).optional(),
    isPrivate: z.boolean().default(true),
});
const UpdateTaskSchema = z.object({
    taskId: z.string(),
    title: z.string().min(1).optional(),
    description: z.string().optional(),
    priority: z.number().min(0).max(3).optional(),
    assigneeId: z.string().optional(),
    dueDateTime: z.string().datetime().optional(),
    reminderTime: z.string().datetime().optional(),
    reminderType: z.enum(["push", "email", "both"]).optional(),
    isPrivate: z.boolean().optional(),
    completed: z.boolean().optional(),
});
const CreateCommentSchema = z.object({
    taskId: z.string(),
    content: z.string().min(1),
    type: z.enum(["TEXT", "MARKDOWN"]).default("TEXT"),
});
// MCP Server class
class AstridMCPServer {
    constructor() {
        this.server = new Server({
            name: "astrid-task-manager",
            version: "1.0.0",
        }, {
            capabilities: {
                resources: {},
                tools: {},
            },
        });
        this.setupHandlers();
    }
    setupHandlers() {
        // List available tools
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            return {
                tools: [
                    {
                        name: "get_shared_lists",
                        description: "Get all task lists that have been shared with the AI agent",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                            },
                            required: ["accessToken"],
                        },
                    },
                    {
                        name: "get_list_tasks",
                        description: "Get all tasks from a specific shared list",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                                listId: {
                                    type: "string",
                                    description: "ID of the list to get tasks from",
                                },
                                includeCompleted: {
                                    type: "boolean",
                                    description: "Whether to include completed tasks",
                                    default: false,
                                },
                            },
                            required: ["accessToken", "listId"],
                        },
                    },
                    {
                        name: "create_task",
                        description: "Create a new task in a shared list",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                                listId: {
                                    type: "string",
                                    description: "ID of the list to create task in",
                                },
                                task: {
                                    type: "object",
                                    properties: {
                                        title: { type: "string" },
                                        description: { type: "string" },
                                        priority: { type: "number", minimum: 0, maximum: 3 },
                                        assigneeId: { type: "string" },
                                        dueDateTime: { type: "string", format: "date-time" },
                                        reminderTime: { type: "string", format: "date-time" },
                                        reminderType: { type: "string", enum: ["push", "email", "both"] },
                                        isPrivate: { type: "boolean" },
                                    },
                                    required: ["title"],
                                },
                            },
                            required: ["accessToken", "listId", "task"],
                        },
                    },
                    {
                        name: "update_task",
                        description: "Update an existing task in a shared list",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                                listId: {
                                    type: "string",
                                    description: "ID of the list containing the task",
                                },
                                taskUpdate: {
                                    type: "object",
                                    properties: {
                                        taskId: { type: "string" },
                                        title: { type: "string" },
                                        description: { type: "string" },
                                        priority: { type: "number", minimum: 0, maximum: 3 },
                                        assigneeId: { type: "string" },
                                        dueDateTime: { type: "string", format: "date-time" },
                                        reminderTime: { type: "string", format: "date-time" },
                                        reminderType: { type: "string", enum: ["push", "email", "both"] },
                                        isPrivate: { type: "boolean" },
                                        completed: { type: "boolean" },
                                    },
                                    required: ["taskId"],
                                },
                            },
                            required: ["accessToken", "listId", "taskUpdate"],
                        },
                    },
                    {
                        name: "add_comment",
                        description: "Add a comment to a task in a shared list",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                                listId: {
                                    type: "string",
                                    description: "ID of the list containing the task",
                                },
                                comment: {
                                    type: "object",
                                    properties: {
                                        taskId: { type: "string" },
                                        content: { type: "string" },
                                        type: { type: "string", enum: ["TEXT", "MARKDOWN"] },
                                    },
                                    required: ["taskId", "content"],
                                },
                            },
                            required: ["accessToken", "listId", "comment"],
                        },
                    },
                    {
                        name: "get_task_comments",
                        description: "Get all comments for a specific task",
                        inputSchema: {
                            type: "object",
                            properties: {
                                accessToken: {
                                    type: "string",
                                    description: "Access token for list access",
                                },
                                listId: {
                                    type: "string",
                                    description: "ID of the list containing the task",
                                },
                                taskId: {
                                    type: "string",
                                    description: "ID of the task to get comments for",
                                },
                            },
                            required: ["accessToken", "listId", "taskId"],
                        },
                    },
                ],
            };
        });
        // List available resources
        this.server.setRequestHandler(ListResourcesRequestSchema, async (request) => {
            return {
                resources: [
                    {
                        uri: "lists://shared",
                        name: "Shared Task Lists",
                        description: "Task lists that have been shared with AI agents",
                        mimeType: "application/json",
                    },
                ],
            };
        });
        // Read resources
        this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
            const { uri } = request.params;
            if (uri === "lists://shared") {
                // Return information about shared lists (without sensitive data)
                return {
                    contents: [
                        {
                            uri,
                            mimeType: "application/json",
                            text: JSON.stringify({
                                description: "Shared task lists accessible via MCP",
                                usage: "Use the get_shared_lists tool with a valid access token to access lists",
                                authentication: "Required: Valid access token with appropriate permissions",
                            }),
                        },
                    ],
                };
            }
            throw new Error(`Unknown resource: ${uri}`);
        });
        // Handle tool calls
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;
            try {
                switch (name) {
                    case "get_shared_lists":
                        return await this.getSharedLists(args);
                    case "get_list_tasks":
                        return await this.getListTasks(args);
                    case "create_task":
                        return await this.createTask(args);
                    case "update_task":
                        return await this.updateTask(args);
                    case "add_comment":
                        return await this.addComment(args);
                    case "get_task_comments":
                        return await this.getTaskComments(args);
                    default:
                        throw new Error(`Unknown tool: ${name}`);
                }
            }
            catch (error) {
                return {
                    content: [
                        {
                            type: "text",
                            text: `Error: ${error instanceof Error ? error.message : String(error)}`,
                        },
                    ],
                    isError: true,
                };
            }
        });
    }
    async validateAccessToken(accessToken, listId, requiredPermission) {
        const tokenData = mcpTokenStore.get(accessToken);
        if (!tokenData) {
            throw new Error("Invalid access token");
        }
        if (tokenData.listId !== listId) {
            throw new Error("Access token not valid for this list");
        }
        if (tokenData.expiresAt && new Date() > tokenData.expiresAt) {
            throw new Error("Access token has expired");
        }
        if (!tokenData.permissions.includes(requiredPermission)) {
            throw new Error(`Insufficient permissions. Required: ${requiredPermission}`);
        }
        return {
            userId: tokenData.userId,
            permissions: tokenData.permissions,
        };
    }
    async getSharedLists(args) {
        const { accessToken } = args;
        if (!accessToken) {
            throw new Error("Access token required");
        }
        // Get all lists this token has access to
        const tokenData = mcpTokenStore.get(accessToken);
        if (!tokenData) {
            throw new Error("Invalid access token");
        }
        const lists = await prisma.taskList.findMany({
            where: {
                id: tokenData.listId,
            },
            include: {
                owner: {
                    select: { id: true, name: true, email: true },
                },
                _count: {
                    select: { tasks: true },
                },
            },
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        lists: lists.map((list) => ({
                            id: list.id,
                            name: list.name,
                            description: list.description,
                            color: list.color,
                            privacy: list.privacy,
                            owner: list.owner,
                            taskCount: list._count.tasks,
                            permissions: tokenData.permissions,
                        })),
                    }),
                },
            ],
        };
    }
    async getListTasks(args) {
        const { accessToken, listId, includeCompleted = false } = args;
        await this.validateAccessToken(accessToken, listId, "read");
        const tasks = await prisma.task.findMany({
            where: {
                lists: {
                    some: { id: listId },
                },
                ...(includeCompleted ? {} : { completed: false }),
            },
            include: {
                assignee: {
                    select: { id: true, name: true, email: true },
                },
                creator: {
                    select: { id: true, name: true, email: true },
                },
                comments: {
                    include: {
                        author: {
                            select: { id: true, name: true, email: true },
                        },
                    },
                    orderBy: { createdAt: "desc" },
                },
                _count: {
                    select: { comments: true },
                },
            },
            orderBy: [
                { completed: "asc" },
                { priority: "desc" },
                { dueDateTime: "asc" },
                { createdAt: "desc" },
            ],
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        listId,
                        tasks: tasks.map((task) => ({
                            id: task.id,
                            title: task.title,
                            description: task.description,
                            priority: task.priority,
                            completed: task.completed,
                            dueDateTime: task.dueDateTime,
                            reminderTime: task.reminderTime,
                            reminderType: task.reminderType,
                            isPrivate: task.isPrivate,
                            createdAt: task.createdAt,
                            updatedAt: task.updatedAt,
                            assignee: task.assignee,
                            creator: task.creator,
                            commentCount: task._count.comments,
                            recentComments: task.comments.slice(0, 3), // Show last 3 comments
                        })),
                    }),
                },
            ],
        };
    }
    async createTask(args) {
        const { accessToken, listId, task } = args;
        const { userId } = await this.validateAccessToken(accessToken, listId, "write");
        // Validate task data
        const validatedTask = CreateTaskSchema.parse(task);
        // Create the task
        const newTask = await prisma.task.create({
            data: {
                ...validatedTask,
                creatorId: userId,
                dueDateTime: validatedTask.dueDateTime ? new Date(validatedTask.dueDateTime) : null,
                reminderTime: validatedTask.reminderTime ? new Date(validatedTask.reminderTime) : null,
                lists: {
                    connect: { id: listId },
                },
            },
            include: {
                assignee: {
                    select: { id: true, name: true, email: true },
                },
                creator: {
                    select: { id: true, name: true, email: true },
                },
                lists: {
                    select: { id: true, name: true },
                },
            },
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        task: {
                            id: newTask.id,
                            title: newTask.title,
                            description: newTask.description,
                            priority: newTask.priority,
                            completed: newTask.completed,
                            dueDateTime: newTask.dueDateTime,
                            reminderTime: newTask.reminderTime,
                            reminderType: newTask.reminderType,
                            isPrivate: newTask.isPrivate,
                            createdAt: newTask.createdAt,
                            assignee: newTask.assignee,
                            creator: newTask.creator,
                            lists: newTask.lists,
                        },
                    }),
                },
            ],
        };
    }
    async updateTask(args) {
        const { accessToken, listId, taskUpdate } = args;
        const { userId } = await this.validateAccessToken(accessToken, listId, "write");
        // Validate task update data
        const validatedUpdate = UpdateTaskSchema.parse(taskUpdate);
        const { taskId, ...updateData } = validatedUpdate;
        // Verify task exists and is in the list
        const existingTask = await prisma.task.findFirst({
            where: {
                id: taskId,
                lists: {
                    some: { id: listId },
                },
            },
        });
        if (!existingTask) {
            throw new Error("Task not found in the specified list");
        }
        // Update the task
        const updatedTask = await prisma.task.update({
            where: { id: taskId },
            data: {
                ...updateData,
                dueDateTime: updateData.dueDateTime ? new Date(updateData.dueDateTime) : undefined,
                reminderTime: updateData.reminderTime ? new Date(updateData.reminderTime) : undefined,
            },
            include: {
                assignee: {
                    select: { id: true, name: true, email: true },
                },
                creator: {
                    select: { id: true, name: true, email: true },
                },
                lists: {
                    select: { id: true, name: true },
                },
            },
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        task: {
                            id: updatedTask.id,
                            title: updatedTask.title,
                            description: updatedTask.description,
                            priority: updatedTask.priority,
                            completed: updatedTask.completed,
                            dueDateTime: updatedTask.dueDateTime,
                            reminderTime: updatedTask.reminderTime,
                            reminderType: updatedTask.reminderType,
                            isPrivate: updatedTask.isPrivate,
                            updatedAt: updatedTask.updatedAt,
                            assignee: updatedTask.assignee,
                            creator: updatedTask.creator,
                            lists: updatedTask.lists,
                        },
                    }),
                },
            ],
        };
    }
    async addComment(args) {
        const { accessToken, listId, comment } = args;
        const { userId } = await this.validateAccessToken(accessToken, listId, "write");
        // Validate comment data
        const validatedComment = CreateCommentSchema.parse(comment);
        // Verify task exists and is in the list
        const existingTask = await prisma.task.findFirst({
            where: {
                id: validatedComment.taskId,
                lists: {
                    some: { id: listId },
                },
            },
        });
        if (!existingTask) {
            throw new Error("Task not found in the specified list");
        }
        // Create the comment
        const newComment = await prisma.comment.create({
            data: {
                ...validatedComment,
                authorId: userId,
            },
            include: {
                author: {
                    select: { id: true, name: true, email: true },
                },
                task: {
                    select: { id: true, title: true },
                },
            },
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        comment: {
                            id: newComment.id,
                            content: newComment.content,
                            type: newComment.type,
                            createdAt: newComment.createdAt,
                            author: newComment.author,
                            task: newComment.task,
                        },
                    }),
                },
            ],
        };
    }
    async getTaskComments(args) {
        const { accessToken, listId, taskId } = args;
        await this.validateAccessToken(accessToken, listId, "read");
        // Verify task exists and is in the list
        const existingTask = await prisma.task.findFirst({
            where: {
                id: taskId,
                lists: {
                    some: { id: listId },
                },
            },
        });
        if (!existingTask) {
            throw new Error("Task not found in the specified list");
        }
        // Get all comments for the task
        const comments = await prisma.comment.findMany({
            where: { taskId },
            include: {
                author: {
                    select: { id: true, name: true, email: true },
                },
            },
            orderBy: { createdAt: "asc" },
        });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        taskId,
                        comments: comments.map((comment) => ({
                            id: comment.id,
                            content: comment.content,
                            type: comment.type,
                            createdAt: comment.createdAt,
                            author: comment.author,
                        })),
                    }),
                },
            ],
        };
    }
    // Methods to manage access tokens are now handled by the API routes
    // The MCP server reads directly from the shared token store
    async run() {
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        console.error("Astrid MCP Server running on stdio");
    }
}
// Run the server if this file is executed directly
if (require.main === module) {
    const server = new AstridMCPServer();
    server.run().catch(console.error);
}
module.exports = AstridMCPServer;
